from pwn import *

#server = remote("127.0.0.1",5000)
#server = remote("crypto.chal.csaw.io",5002)
server = remote("localhost",12345)
print(server.recvline())

def SmartAttack():
	print(server.recvline())
	print(server.recvline())
	print(server.recvline())
	p_data = server.recvline().split()
	a_data = server.recvline().split()
	b_data = server.recvline().split()
	p = int(p_data[2])
	a = int(a_data[2])
	b = int(b_data[2])
	print("p =",p,"\na =",a,"\nb =",b)
	print(server.recvline())
	P_data = server.recvline().split(b": ")
	Q_data = server.recvline().split(b": ")
	px = int(P_data[1][1:])
	py = int(P_data[2])
	qx = int(Q_data[1][1:])
	qy = int(Q_data[2])
	print("P1 =",px,",",py)
	print("P2 =",qx,",",qy)
	print(server.recvline())
	print(server.recvline())
	print(server.recvline())
	E = EllipticCurve(GF(p), [a, b])
	assert(E.order() == p)
	P = E(px,py)
	Q = E(qx,qy)
	Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ])
	P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True)
	for P_Qp in P_Qps:
		if GF(p)(P_Qp.xy()[1]) == P.xy()[1]:
			break
	Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True)
	for Q_Qp in Q_Qps:
		if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]:
			break
	p_times_P = p*P_Qp
	p_times_Q = p*Q_Qp
	x_P,y_P = p_times_P.xy()
	x_Q,y_Q = p_times_Q.xy()
	phi_P = -(x_P/y_P)
	phi_Q = -(x_Q/y_Q)
	k = phi_Q/phi_P
	ans = str(ZZ(k))
	print(ans)
	server.sendline(ans)

def mov_attack():
	print(server.recvline())
	print(server.recvline())
	print(server.recvline())
	p_data = server.recvline().split()
	a_data = server.recvline().split()
	b_data = server.recvline().split()
	p = int(p_data[2])
	a = int(a_data[2])
	b = int(b_data[2])
	print("p =",p,"\na =",a,"\nb =",b)
	print(server.recvline())
	P_data = server.recvline().split(b": ")
	Q_data = server.recvline().split(b": ")
	px = int(P_data[1][1:])
	py = int(P_data[2])
	qx = int(Q_data[1][1:])
	qy = int(Q_data[2])
	print("P1 =",px,",",py)
	print("P2 =",qx,",",qy)
	print(server.recvline())
	print(server.recvline())
	print(server.recvline())
	E = EllipticCurve(GF(p), [a, b])
	order = E.order()
	P = E(px,py)
	Q = E(qx,qy)
	n = P.order()
	k = 1
	while (p**k - 1) % order:
		k += 1
	K.<a> = GF(p**k)
	EK = E.base_extend(K)
	PK = EK(Q)
	GK = EK(P)
	while True:
		R = EK.random_point()
		m = R.order()
		d = gcd(m,n)
		S = (m//d)*R
		if n / S.order() not in ZZ:
			continue
		if n == S.order():
			break
	alpha = GK.weil_pairing(S,n)
	beta = PK.weil_pairing(S,n)
	dd = beta.log(alpha)
	ans = str(dd)
	print(ans)
	server.sendline(ans)

def singular_curves():
	print(server.recvline())
	print(server.recvline())
	print(server.recvline())
	p_data = server.recvline().split()
	a_data = server.recvline().split()
	b_data = server.recvline().split()
	p = int(p_data[2])
	print("p =",p,"\na = ???\nb = ???")
	print(server.recvline())
	G_data = server.recvline().split()
	P_data = server.recvline().split()
	Gx = int(G_data[1][1:-1])
	Gy = int(G_data[2][:-1])
	Px = int(P_data[1][1:-1])
	Py = int(P_data[2][:-1])
	print("P1 =",Gx,",",Gy)
	print("P2 =",Px,",",Py)
	print(server.recvline())
	print(server.recvline())
	print(server.recvline())
	F = GF(p)
	gx = F(Gx)
	gy = F(Gy)
	px = F(Px)
	py = F(Py)
	a = ((gy^2 - py^2)-(gx^3 - px^3))/(gx - px)
	b = gy^2 - (gx^3 + a*gx)
	D = 4*(a^3) + 27*(b^2)
	P.<x> = F[]
	f = x^3 + a*x + b
	f_factors = f.factor()
	r = F(f_factors[1][0] - x)
	f_ = f.subs(x=x-r)
	ff = f_.factor()
	t = F(ff[0][0]-x).square_root()
	u = ((gy + t*(gx+r))/(gy - t*(gx+r)))
	v = ((py + t*(px+r))/(py - t*(px+r)))
	n = discrete_log(v, u)
	ans = str(n)
	print(ans)
	server.sendline(ans)

SmartAttack()
print(server.recvline())
print(server.recvline())
mov_attack()
print(server.recvline())
print(server.recvline())
singular_curves()
server.interactive()
server.close()
