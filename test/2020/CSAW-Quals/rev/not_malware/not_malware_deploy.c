/*
 * not_malware.c
 *
 *      Main executable distributed to the user for analysis, and contains
 *      the checking routine to determine whether the user should receive the flag or not.
 *
 *      Final input should look something like this:
 *          softbank:475:71651660587965760966:end
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include <unistd.h>

#include "goaway.h"

#define BUF_SIZE 60
#define CC_LEN 20

const char BANK_NAMES[6][9] = {
    "yeetbank",
    "peepbank",
    "heapbank",
    "softbank", // we only take CCs from softbank!
    "seatbank",
    "zorpbank"
};

static void win(void) {
    FILE *file;
    char buf[255];
    file = fopen("flag.txt", "r");
    fscanf(file, "%s", buf);
    printf("%s\n", buf);
    fclose(file);
}


/* generate a deterministic value given a seed number */
uint64_t seed(int seedint) {
    srand(seedint);
    return rand();
}


/* anti-analysis calls */
void go_away(void) {
    hypervisors_are_scary();
    no_sneaky_loading();
    //stop_intruders();
}


int main(void)
{
    //go_away();
    setvbuf(stdout, NULL, _IONBF, 0);

    int ind, c;
    int seeder, incrementer, indexer;
    char our_bank[8];

    printf("What's your credit card number (for safekeeping) ?\n>> ");

    /* read credit card from STDIN */
    char input[BUF_SIZE];
    fgets(input, sizeof(input), stdin);

    /* This is actually a useless check meant to waste a symbolic executors time, since fgets truncates the length. */
    if (strlen(input) > BUF_SIZE) {
        printf("Well this was unnecessary.\n");
        exit(EXIT_FAILURE);
    }

    /* selects the bank we only trust */
    ind = 0;
    ind = ind + 256;
    ind = (ind >> 2) >> 2;
    ind = pow(ind, 0.5) - 1;

    /* grab first 8 chars as slice of string */
    c = 0;
    while (c < 8) {
        our_bank[c] = input[c];
        c++;
    }
    our_bank[c] = '\0';

    /* check if our bank is correct from slice */
    if (strncmp(our_bank, BANK_NAMES + ind, 8) != 0) {
        exit(EXIT_FAILURE);
    }

    /* check if we have a seperator after bank name */
    if (input[8] != ':') {
        printf("Get out.\n");
        exit(EXIT_FAILURE);
    }

    /* parse first number in input as `seed()` input */
    seeder = input[9] - '0';

    /* parse second number as increment counter to `seed()` input */
    incrementer = input[10] - '0';

    /* value to index from each generated number to recover the CC */
    indexer = input[11] - '0';

    /* check if we have a seperator after two "index nums" */
    if (input[12] != ':') {
        printf("Get out.\n");
        exit(EXIT_FAILURE);
    }

    /* parse out the CC number by creating a determinstic num from the seeder, indexing it
     * with the indexer, and resetting the seeder with the incrementer until cc is full */
    char cc[CC_LEN];
    for (int i = 0; i < CC_LEN; i++) {
        char seedval[10];
        snprintf(seedval, 10, "%ld", seed(seeder));
        cc[i] = seedval[indexer];
        seeder += incrementer;
    }

    /* read slice from the original input to compare (13 to 33) */
    c = 0;
    char our_cc[CC_LEN];
    while (c < CC_LEN) {
        our_cc[c] = input[c + 13];
        c++;
    }

    /* randomized index check for all the values that make up the target we want */
   if (our_cc[0] != cc[0]) exit(EXIT_FAILURE);
   if (our_cc[16] != cc[16]) exit(EXIT_FAILURE);
   if (our_cc[11] != cc[11]) exit(EXIT_FAILURE);
   if (our_cc[3] != cc[3]) exit(EXIT_FAILURE);
   if (our_cc[7] != cc[7]) exit(EXIT_FAILURE);
   if (our_cc[15] != cc[15]) exit(EXIT_FAILURE);
   if (our_cc[1] != cc[1]) exit(EXIT_FAILURE);
   if (our_cc[12] != cc[12]) exit(EXIT_FAILURE);
   if (our_cc[19] != cc[19]) exit(EXIT_FAILURE);
   if (our_cc[13] != cc[13]) exit(EXIT_FAILURE);
   if (our_cc[14] != cc[14]) exit(EXIT_FAILURE);
   if (our_cc[5] != cc[5]) exit(EXIT_FAILURE);
   if (our_cc[9] != cc[9]) exit(EXIT_FAILURE);
   if (our_cc[8] != cc[8]) exit(EXIT_FAILURE);
   if (our_cc[18] != cc[18]) exit(EXIT_FAILURE);
   if (our_cc[6] != cc[6]) exit(EXIT_FAILURE);
   if (our_cc[17] != cc[17]) exit(EXIT_FAILURE);
   if (our_cc[2] != cc[2]) exit(EXIT_FAILURE);
   if (our_cc[10] != cc[10]) exit(EXIT_FAILURE);
   if (our_cc[4] != cc[4]) exit(EXIT_FAILURE);

	/* check if we have a seperator after cc num */
    if (input[33] != ':') {
        printf("Get out.\n");
        exit(EXIT_FAILURE);
    }

	c = 0;
	char end[] = "end";
	while (c < 3) {
		if (end[c] != input[c + 34])
			exit(EXIT_FAILURE);
		c++;
	}

    /* return flag */
	printf("Thanks!\n");
    win();
    return 0;
}
